import React from "react"
import Path from "path"
import {ChunkExtractor} from "@loadable/server"
import ReactDomServer from "react-dom/server"
import {App} from "../js/components/App";
import {StaticRouter} from "react-router-dom/server";
import window from "global/window"
import {ThemeProvider} from "@mui/material/styles";
import {theme} from "./theme";
import {validateEmail} from "../js/validateEmail";
import http2 from "http2";
import fs from "fs";
import fetch from "node-fetch";
import {sendEmail} from "./email";
import Hapi from "@hapi/hapi";
import {Helmet} from "react-helmet";
import bcrypt from 'bcryptjs'
import conf from '../../app.config'
import jwt from "jsonwebtoken";
import { request } from "http";
import { authenticated } from "./authentication";
import { createBlogHandler, deleteBlogHandler, getBlogs, retrieveBlogsHandler, updateBlogHandler } from "./BlogController";

const config = conf.default

global.window = window
global.self = window
// This is the stats file generated by webpack loadable plugin
const statsFile = Path.resolve('./dist/loadable-stats.json')
// We create an extractor from the statsFile
const extractor = new ChunkExtractor({ statsFile:statsFile })


const dataDir = "./data"
const readMe = {}
const reposDir = dataDir+"/repos.json"
let repos = {
    lastUpdatedEpoch:0,
    data:[]
};

const isBot = (req) => {
    const botPattern = "(googlebot\/|bot|Googlebot-Mobile|Googlebot-Image|Google favicon|Mediapartners-Google|bingbot|slurp|java|wget|curl|Commons-HttpClient|Python-urllib|libwww|httpunit|nutch|phpcrawl|msnbot|jyxobot|FAST-WebCrawler|FAST Enterprise" +
    " Crawler|biglotron|teoma|convera|seekbot|gigablast|exabot|ngbot|ia_archiver|GingerCrawler|webmon |httrack|webcrawler|grub.org|UsineNouvelleCrawler|antibot|netresearchserver|speedy|fluffy|bibnum.bnf|findlink|msrbot|panscient|yacybot|AISearchBot|IOI|ips-agent|tagoobot|MJ12bot|dotbot|woriobot|yanga|buzzbot|mlbot|yandexbot|purebot|Linguee Bot|Voyager|CyberPatrol|voilabot|baiduspider|citeseerxbot|spbot|twengabot|postrank|turnitinbot|scribdbot|page2rss|sitebot|linkdex|Adidxbot|blekkobot|ezooms|dotbot|Mail.RU_Bot|discobot|heritrix|findthatfile|europarchive.org|NerdByNature.Bot|sistrix crawler|ahrefsbot|Aboundex|domaincrawler|wbsearchbot|summify|ccbot|edisterbot|seznambot|ec2linkfinder|gslfbot|aihitbot|intelium_bot|facebookexternalhit|yeti|RetrevoPageAnalyzer|lb-spider|sogou|lssbot|careerbot|wotbox|wocbot|ichiro|DuckDuckBot|lssrocketcrawler|drupact|webcompanycrawler|acoonbot|openindexspider|gnam gnam spider|web-archive-net.com.bot|backlinkcrawler|coccoc|integromedb|content crawler spider|toplistbot|seokicks-robot|it2media-domain-crawler|ip-web-crawler.com|siteexplorer.info|elisabot|proximic|changedetection|blexbot|arabot|WeSEE:Search|niki-bot|CrystalSemanticsBot|rogerbot|360Spider|psbot|InterfaxScanBot|Lipperhey SEO Service|CC Metadata Scaper|g00g1e.net|GrapeshotCrawler|urlappendbot|brainobot|fr-crawler|binlar|SimpleCrawler|Livelapbot|Twitterbot|cXensebot|smtbot|bnf.fr_bot|A6-Indexer|ADmantX|Facebot|Twitterbot|OrangeBot|memorybot|AdvBot|MegaIndex|SemanticScholarBot|ltx71|nerdybot|xovibot|BUbiNG|Qwantify|archive.org_bot|Applebot|TweetmemeBot|crawler4j|findxbot|SemrushBot|yoozBot|lipperhey|y!j-asr|Domain Re-Animator Bot|AddThis)";
    const re = new RegExp(botPattern, 'i');
    const userAgent = req.headers["user-agent"]
    
    return re.test(userAgent)
}

const offlineRender = (req, h) => {
    return new Promise((resolve, reject) => {
        fs.readFile("dist/index.html", 'utf8', (err, data) => {
            
            if (err) reject(h.response().status(500))
            
            getRepos()
            .then(json => json.data)
            .then(gitData =>{
                // Wrap your application using "collectChunks"
                const jsx = extractor.collectChunks(
                    <ThemeProvider theme={theme}>
                    <StaticRouter location={req.url.pathname}>
                    <App data={{git:gitData, blogs: getBlogs()}}/>
                    </StaticRouter>
                    </ThemeProvider>)
                    // Render your application
                    
                    const html = ReactDomServer.renderToString(jsx)
                    const helmet = Helmet.renderStatic();
                    
                    
                    
                    let result = data.replace(/<title>Pavel Vjalicin - About Me<\/title>/g,helmet.title.toString())
                    
                    result = result.replace(/<meta name="description" content="Pavel Vjalicin - About Me"\/>/g,helmet.meta.toString())
                    
                    
                    result = result.replace(/<div id="react"><\/div>/g,
                    `<div id="react">${html}</div>`)
                    
                    resolve(
                        result
                        )
                    })
                    
                })
            })
        }
        
        const favicon = fs.readFileSync("./favicon.ico")
        
        if(!fs.existsSync(dataDir))
        fs.mkdirSync(dataDir)
        
        function updateRepo() {
            console.log("GitHub repos updated")
            return fetch("https://api.github.com/users/PavelVjalicin/repos")
            .then(resp => {
                if (resp.ok) return resp
                else throw "GitHub server error"
            })
            .then(resp => resp.json())
            .then(json => {
                if (fs.existsSync(reposDir)) fs.unlinkSync(reposDir)
                json.sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at))
                const resp = {lastUpdatedEpoch: Date.now(), data: json}
                fs.writeFile(reposDir, JSON.stringify(resp), (err) => {
                })
                return resp
            })
        }
        
        async function getRepos() {
            if(repos.data.length === 0) {
                if(fs.existsSync(reposDir))  {
                    //Retrieve from cache
                    try {
                        const json = JSON.parse(fs.readFileSync(reposDir));
                        if(json.lastUpdatedEpoch + (2*60*60*1000) < Date.now() ) {
                            return await updateRepo()
                        } else return json
                    } catch (e) {
                        return await updateRepo()
                    }
                    
                } else {
                    return await updateRepo()
                }
                
            } else if(repos.lastUpdatedEpoch + (2*60*60*1000) < Date.now() ) {
                //Update
                return await updateRepo()
            } else {
                //Return in memory
                return repos
            }
        }
        
        async function updateReadme(repo,fileDir) {
            console.log(`Github ${repo} Readme updated`)
            return fetch(`https://raw.githubusercontent.com/pavelVjalicin/${repo}/master/README.md`)
            .then(resp => {
                if(resp.ok) return resp.text()
                else if(resp.status === 404 ) {
                    return repo + " does not have a README.md file."
                } else {
                    console.log(resp)
                    throw "Github server error"
                }
            })
            .then(body => {
                if (fs.existsSync(fileDir)) fs.unlinkSync(fileDir)
                const resp = {lastUpdatedEpoch: Date.now(), data: body}
                fs.writeFile(fileDir, JSON.stringify(resp), (err) => {
                })
                return resp
            })
            
        }
        
        async function getReadme(repo) {
            const inMemoryReadme = readMe[repo]
            const fileName = dataDir+`/${repo}_README.json`
            if(inMemoryReadme) {
                if(inMemoryReadme.lastUpdatedEpoch + (2*60*60*1000) < Date.now()) {
                    //Update
                    readMe[repo] = await updateReadme(repo,fileName)
                    return readMe[repo].data
                } else {
                    //Return in memory
                    return inMemoryReadme.data
                }
            } else {
                if(fs.existsSync(fileName)) {
                    //Retrieve from cache
                    const json = JSON.parse(fs.readFileSync(fileName))
                    if(json.lastUpdatedEpoch + (2*60*60*1000) < Date.now()) {
                        //update
                        readMe[repo] = await updateReadme(repo,fileName)
                        return readMe[repo].data
                    } else {
                        readMe[repo] = { lastUpdatedEpoch:json, data:json.data}
                        return json.data
                    }
                } else {
                    //Update
                    readMe[repo] = await updateReadme(repo,fileName)
                    return readMe[repo].data
                }
                
            }
        }
        
        const initHapi = async (isProd) => {
            
            const dir = Path.resolve(__dirname, '../..')
            let server
            if(isProd) {
                server = Hapi.Server({
                    port: "./passenger",
                    routes: {
                        files: {
                            relativeTo: dir
                        }
                    }
                })
            } else {
                const listener = http2.createSecureServer(
                    {
                        key:fs.readFileSync("private.pem"),
                        cert:fs.readFileSync("cert.pem")
                    }
                    )
                    server = Hapi.Server({
                        listener,
                        port: 8080,
                        routes: {
                            files: {
                                relativeTo: dir
                            }
                        }
                    })
                }
                
                await server.register(require("@hapi/inert"))
                
                server.route([
                    {
                        method:'POST',
                        path:'/login',
                        handler: async (req,h) => {
                            const { password } = req.payload
                            if(bcrypt.compareSync( password, config.admin_hash)){
                                const signature = jwt.sign({}, config.secret, { expiresIn: "5h"})
                                h.state("t",signature)
                                return h.response("").code(200)
                            } else {
                                return h.response("").code(404)
                            }
                            
                        }
                    },
                    {
                        method:'GET',
                        path:'/logout',
                        handler: (req,h) => {
                            h.unstate("t")
                            const redirect = req.query.redirect
                            if(redirect) {
                                return h.redirect(redirect)
                            } else {
                                return h.redirect("/")
                            }
                            
                        }
                    },
                    {
                        method:'GET',
                        path:'/api/auth',
                        handler: authenticated((req, h) => h.response("").code(200)) 
                    },
                    {
                        method:'GET',
                        path:'/robots.txt',
                        handler: (req,h) =>
                        h.file("robots.txt")
                        
                    },{
                        method:'GET',
                        path:'/favicon.ico',
                        handler: (req,h) =>
                        h.response(favicon).header('Content-Length', favicon.length)
                        .header('Content-Type', 'image/x-icon')
                        .header("Cache-Control", "public, max-age=2592000") //Expires in a month
                        .header("Expires", new Date(Date.now() + 2592000000).toUTCString())
                        
                    },{
                        method:'GET',
                        path:"/api/repo",
                        handler:(req,h) => {
                            return getRepos().then(r => {
                                repos = r
                                return JSON.stringify(repos.data)
                            })
                        }
                    },{
                        method:"GET",
                        path:"/api/readme/{repo}",
                        handler:(req,h) => {
                            const repo = req.params.repo
                            return getReadme(repo)
                        }
                    },{
                        method:"POST",
                        path:"/api/contact",
                        handler: (req,h) => {
                            const {name,email,message} = req.payload
                            if(name && validateEmail(email) && message) {
                                return sendEmail(email,name,message)
                                .then( resp => h.response().code(200) )
                                .catch( e => h.response(JSON.stringify({error:"Something went wrong"})).code(500) )
                            } else {
                                return h.response(JSON.stringify({error:"Form was not filled in correctly."})).code(500)
                            }
                        }
                    },{
                        method:'GET',
                        path:"/api/blog",
                        handler: retrieveBlogsHandler
                    },{
                        method:'POST',
                        path:"/api/blog",
                        handler: createBlogHandler
                    },{
                        method:'PATCH',
                        path:"/api/blog/{id}",
                        handler: updateBlogHandler
                    },{
                        method:'DELETE',
                        path:"/api/blog/{id}",
                        handler: deleteBlogHandler
                    },{
                        method:'GET',
                        path:"/dist/{any*}",
                        handler: (req,h) => {
                            const type = req.params.any.split(".").pop()
                            const dir = "dist/"+req.params.any
                            const fileDir = "./"+dir+".gz"
                            
                            let resp
                            
                            if(!fs.existsSync(fileDir)) {
                                resp = h.file(dir)
                            } else {
                                resp = h.file(dir+".gz")
                                resp.header('Content-Encoding', 'gzip')
                            }
                            
                            
                            if(type === "js") resp.header("Content-Type","text/javascript")
                            else if(type === "css") resp.header("Content-Type","text/css")
                            
                            return resp
                        },
                        options: {
                            cache: {
                                expiresIn: 3600 * 1000
                            }
                        }
                    },{
                        method:'GET',
                        path:"/public/{any*}",
                        handler: (req,h) => {
                            return h.file("public/"+req.params.any)
                        }
                    },{
                        method:'GET',
                        path:'/{any*}',
                        handler: (req,h) => {
                            
                            if(isBot(req)) {
                                return offlineRender(req,h)
                            } else {
                                return h.file("dist/index.html")
                            }
                        }
                    }])
                    
                    await server.start(err => {
                        if(err) console.log(err)
                    })
                    
                    console.log('Server running at:', server.info.uri);
                }
                
                exports.default = initHapi
                